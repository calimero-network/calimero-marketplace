/** @generated by @calimero/abi-codegen â€” DO NOT EDIT. */

import { CalimeroApp, Context } from '@calimero-network/calimero-client';

// Generated types

export type EscrowStatusPayload =
  | { name: 'Pending' }
  | { name: 'Released' }
  | { name: 'Refunded' };

export const EscrowStatus = {
  Pending: (): EscrowStatusPayload => ({ name: 'Pending' }),
  Released: (): EscrowStatusPayload => ({ name: 'Released' }),
  Refunded: (): EscrowStatusPayload => ({ name: 'Refunded' }),
} as const;

export interface MarketplaceApp {
  admin_wallet: string;
  store_name: string;
  type_of_goods: string;
  seller_requests: Record<string, SellerRequest>;
  sellers: Record<string, SellerInfo>;
  products: Record<string, Product>;
  orders: Record<string, Order>;
  seller_counter: number;
  product_counter: number;
  order_counter: number;
}

export interface Order {
  id: string;
  buyer_wallet: string;
  product_id: string;
  seller_id: string;
  amount: string;
  escrow_status: EscrowStatus;
  qr_payload: string;
  created_at: number;
  delivered_at: number | null;
}

export interface Product {
  id: string;
  seller_id: string;
  name: string;
  description: string;
  quantity: number;
  price: string;
  image_url: string;
  category: string;
  shipping_info: string;
  created_at: number;
}

export interface SellerInfo {
  id: string;
  wallet_address: string;
  company_name: string;
  company_details: string;
  approved_at: number;
}

export interface SellerRequest {
  id: string;
  wallet_address: string;
  company_name: string;
  company_details: string;
  signature: string;
  timestamp: number;
  approved: boolean;
}

/**
 * Utility class for handling byte conversions in Calimero
 */
export class CalimeroBytes {
  private data: Uint8Array;

  constructor(input: string | number[] | Uint8Array) {
    if (typeof input === 'string') {
      // Hex string
      this.data = new Uint8Array(
        input.match(/.{1,2}/g)?.map((byte) => parseInt(byte, 16)) || [],
      );
    } else if (Array.isArray(input)) {
      // Number array
      this.data = new Uint8Array(input);
    } else {
      // Uint8Array
      this.data = input;
    }
  }

  toArray(): number[] {
    return Array.from(this.data);
  }

  toUint8Array(): Uint8Array {
    return this.data;
  }

  static fromHex(hex: string): CalimeroBytes {
    return new CalimeroBytes(hex);
  }

  static fromArray(arr: number[]): CalimeroBytes {
    return new CalimeroBytes(arr);
  }

  static fromUint8Array(bytes: Uint8Array): CalimeroBytes {
    return new CalimeroBytes(bytes);
  }
}

/**
 * Convert CalimeroBytes instances to arrays for WASM compatibility
 */
function convertCalimeroBytesForWasm(obj: any): any {
  if (obj === null || obj === undefined) {
    return obj;
  }

  if (obj instanceof CalimeroBytes) {
    return obj.toArray();
  }

  if (Array.isArray(obj)) {
    return obj.map((item) => convertCalimeroBytesForWasm(item));
  }

  if (typeof obj === 'object') {
    const result: any = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = convertCalimeroBytesForWasm(value);
    }
    return result;
  }

  return obj;
}

/**
 * Convert arrays back to CalimeroBytes instances from WASM responses
 */
function convertWasmResultToCalimeroBytes(obj: any): any {
  if (obj === null || obj === undefined) {
    return obj;
  }

  if (Array.isArray(obj) && obj.every((item) => typeof item === 'number')) {
    return new CalimeroBytes(obj);
  }

  if (Array.isArray(obj)) {
    return obj.map((item) => convertWasmResultToCalimeroBytes(item));
  }

  if (typeof obj === 'object') {
    const result: any = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = convertWasmResultToCalimeroBytes(value);
    }
    return result;
  }

  return obj;
}

export class AbiClient {
  private app: CalimeroApp;
  private context: Context;

  constructor(app: CalimeroApp, context: Context) {
    this.app = app;
    this.context = context;
  }

  /**
   * init
   */
  public async init(): Promise<void> {
    const response = await this.app.execute(this.context, 'init', {});
    if (response.success) {
      return response.result as void;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * setup_marketplace
   */
  public async setupMarketplace(params: {
    admin_wallet: string;
    store_name: string;
    type_of_goods: string;
  }): Promise<string> {
    const response = await this.app.execute(
      this.context,
      'setup_marketplace',
      params,
    );
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_marketplace_info
   */
  public async getMarketplaceInfo(): Promise<string> {
    const response = await this.app.execute(
      this.context,
      'get_marketplace_info',
      {},
    );
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * request_seller_access
   */
  public async requestSellerAccess(params: {
    wallet_address: string;
    company_name: string;
    company_details: string;
    signature: string;
  }): Promise<string> {
    const response = await this.app.execute(
      this.context,
      'request_seller_access',
      params,
    );
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * admin_approve_seller
   */
  public async adminApproveSeller(params: {
    seller_id: string;
  }): Promise<void> {
    const response = await this.app.execute(
      this.context,
      'admin_approve_seller',
      params,
    );
    if (response.success) {
      return response.result as void;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * add_product
   */
  public async addProduct(params: {
    seller_wallet: string;
    name: string;
    description: string;
    quantity: number;
    price: string;
    image_url: string;
    category: string;
    shipping_info: string;
    _signature: string;
  }): Promise<string> {
    const response = await this.app.execute(
      this.context,
      'add_product',
      params,
    );
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * purchase_product
   */
  public async purchaseProduct(params: {
    product_id: string;
    buyer_wallet: string;
    amount: string;
    _signature: string;
  }): Promise<string> {
    const response = await this.app.execute(
      this.context,
      'purchase_product',
      params,
    );
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_delivery_payload
   */
  public async getDeliveryPayload(params: {
    order_id: string;
  }): Promise<string> {
    const response = await this.app.execute(
      this.context,
      'get_delivery_payload',
      params,
    );
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * confirm_delivery
   */
  public async confirmDelivery(params: {
    order_id: string;
    _buyer_signature: string;
  }): Promise<void> {
    const response = await this.app.execute(
      this.context,
      'confirm_delivery',
      params,
    );
    if (response.success) {
      return response.result as void;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_products
   */
  public async getProducts(): Promise<string> {
    const response = await this.app.execute(this.context, 'get_products', {});
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_sellers
   */
  public async getSellers(): Promise<string> {
    const response = await this.app.execute(this.context, 'get_sellers', {});
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_pending_seller_requests
   */
  public async getPendingSellerRequests(): Promise<string> {
    const response = await this.app.execute(
      this.context,
      'get_pending_seller_requests',
      {},
    );
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_orders
   */
  public async getOrders(): Promise<string> {
    const response = await this.app.execute(this.context, 'get_orders', {});
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_order
   */
  public async getOrder(params: { order_id: string }): Promise<string> {
    const response = await this.app.execute(this.context, 'get_order', params);
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_admin_wallet
   */
  public async getAdminWallet(): Promise<string> {
    const response = await this.app.execute(
      this.context,
      'get_admin_wallet',
      {},
    );
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }
}
